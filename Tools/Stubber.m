#import "Utils.h"

NSString* oldPath;
NSString* newPath;
NSString* codePath;
NSString* outPath;

NSString* name;
NSMutableArray<NSString*>* symbols;
NSMutableString* output;
NSMutableString* shims;
NSMutableArray<NSString*>* classNames;
NSMutableArray<NSString*>* constantNames;
NSMutableArray<NSString*>* functionNames;
NSString* shimMainPath;

NSArray<NSString*>* getSymbols(NSString* path)
{
	NSString* symbolsString;
	
	if(runTask(@[@"/usr/bin/nm",@"-gUj",path],nil,&symbolsString))
	{
		return nil;
	}
	
	return [symbolsString componentsSeparatedByString:@"\n"];
}

const int TYPE_ONCE=0;
const int TYPE_PER_SYMBOL=1;

// TODO: weird
const int RET_ERROR=-1;
const int RET_NULL=-2;
const int RET_DONE_KEEP=-3;
const int RET_DONE_DELETE=-4;
const int RET_YES=-5;
const int RET_NO=-6;

NSMutableArray<NSString*>* taskNames;
NSMutableArray<NSNumber*>* taskTypes;
NSMutableArray<int(^)()>* taskBlocks;

void addTask(NSString* name,int type,int (^block)())
{
	[taskNames addObject:name];
	
	[taskTypes addObject:[NSNumber numberWithInt:type]];
	
	int (^heapBlock)()=Block_copy(block);
	[taskBlocks addObject:heapBlock];
	Block_release(heapBlock);
}

void setupTasks()
{
	taskNames=NSMutableArray.alloc.init;
	taskTypes=NSMutableArray.alloc.init;
	taskBlocks=NSMutableArray.alloc.init;
	
	addTask(@"compare symbols",TYPE_ONCE,^int()
	{
		NSArray<NSString*>* oldSymbols=getSymbols(oldPath);
		NSArray<NSString*>* newSymbols=getSymbols(newPath);
		
		if(!oldSymbols||!newSymbols)
		{
			return RET_ERROR;
		}
		
		symbols=NSMutableArray.alloc.init;
		for(NSString* newSymbol in newSymbols)
		{
			if([oldSymbols indexOfObject:newSymbol]==NSNotFound)
			{
				NSString* symbolNoUnderscore=[newSymbol substringFromIndex:1];
				[symbols addObject:symbolNoUnderscore];
			}
		}
		
		return symbols.count;
	});
	
	addTask(@"init output",TYPE_ONCE,^int()
	{
		output=NSMutableString.alloc.init;
	
		[output appendString:@"// generated by Stubber\n"];
		
		[output appendString:@"#import \"Utils.h\"\n"];
		
		return RET_NULL;
	});
	
	addTask(@"read shims",TYPE_ONCE,^int()
	{
		shims=NSMutableString.alloc.init;
		shimMainPath=nil;
		
		NSString* folderPath=[codePath stringByAppendingPathComponent:name];
		
		NSError* error=nil;
		NSArray<NSString*>* fileNames=[NSFileManager.defaultManager contentsOfDirectoryAtPath:folderPath error:&error];
		if(error)
		{
			return RET_NO;
		}
		
		unsigned int count=0;
		for(NSString* fileName in fileNames)
		{
			if([fileName hasSuffix:@".m"])
			{
				NSString* filePath=[folderPath stringByAppendingPathComponent:fileName];
				
				if([fileName isEqual:@"Main.m"])
				{
					shimMainPath=filePath;
				}
				
				NSString* shimString=[NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
				[shims appendString:shimString];
				[shims appendString:@"\n"];
				count++;
			}
		}
		
		return count;
	});
	
	addTask(@"remove explicit ignores",TYPE_PER_SYMBOL,^int(NSString* symbol)
	{
		NSString* check=[NSString stringWithFormat:@"// nostub %@",symbol];
		return [shims containsString:check]?RET_DONE_DELETE:RET_NULL;
	});
	
	addTask(@"init classes",TYPE_ONCE,^int()
	{
		classNames=NSMutableArray.alloc.init;
		return RET_NULL;
	});
	
	addTask(@"add classes",TYPE_PER_SYMBOL,^int(NSString* symbol)
	{
		if([symbol containsString:@"OBJC_CLASS_$_"])
		{
			NSString* className=[symbol substringFromIndex:13];
			[classNames addObject:className];
			return RET_DONE_DELETE;
		}
		return RET_NULL;
	});
	
	addTask(@"remove metaclasses",TYPE_PER_SYMBOL,^int(NSString* symbol)
	{
		return [symbol containsString:@"OBJC_METACLASS_$_"]?RET_DONE_DELETE:RET_NULL;
	});
	
	addTask(@"add ivars",TYPE_PER_SYMBOL,^int(NSString* symbol)
	{
		if([symbol containsString:@"OBJC_IVAR_$_"])
		{
			trace(@"UNIMPLEMENTED");
			return RET_ERROR;
		}
		return RET_NULL;
	});
	
	addTask(@"remove shim classes",TYPE_ONCE,^int()
	{
		unsigned int count=0;
		for(unsigned int index=0;index<classNames.count;index++)
		{
			NSString* check=[NSString stringWithFormat:@"@interface %@:",classNames[index]];
			if([shims containsString:check])
			{
				[classNames removeObjectAtIndex:index];
				index--;
				count++;
			}
		}
		return count;
	});
	
	addTask(@"commit classes",TYPE_ONCE,^int()
	{
		if(classNames.count>0)
		{
			NSString* classPath=[codePath stringByAppendingPathComponent:@"Stub.m"];
			NSString* classString=[NSString stringWithContentsOfFile:classPath encoding:NSUTF8StringEncoding error:nil];
			
			if(!classString)
			{
				return RET_ERROR;
			}
			
			NSString* stubClassName=[name stringByAppendingString:@"StubClass"];
			classString=[classString stringByReplacingOccurrencesOfString:@"%name%" withString:stubClassName];
			
			[output appendString:classString];
			[output appendString:@"\n"];
			
			for(unsigned int index=0;index<classNames.count;index++)
			{
				NSString* className=classNames[index];
				[output appendFormat:@"@interface %@:%@\n@end\n@implementation %@\n@end\n",className,stubClassName,className];
			}
		}
		
		return classNames.count;
	});
	
	addTask(@"init constants",TYPE_ONCE,^int()
	{
		constantNames=NSMutableArray.alloc.init;
		return RET_NULL;
	});
	
	addTask(@"add constants",TYPE_PER_SYMBOL,^int(NSString* symbol)
	{
		if([NSCharacterSet.lowercaseLetterCharacterSet characterIsMember:[symbol characterAtIndex:0]])
		{
			[constantNames addObject:symbol];
			return RET_DONE_DELETE;
		}
		return RET_NULL;
	});
	
	addTask(@"remove shim constants",TYPE_ONCE,^int()
	{
		unsigned int count=0;
		for(unsigned int index=0;index<constantNames.count;index++)
		{
			NSString* check=[NSString stringWithFormat:@" %@=",constantNames[index]];
			if([shims containsString:check])
			{
				[constantNames removeObjectAtIndex:index];
				index--;
				count++;
			}
		}
		return count;
	});
	
	addTask(@"commit constants",TYPE_ONCE,^int()
	{
		for(NSString* constantName in constantNames)
		{
			[output appendFormat:@"NSString* %@=@\"%@\";\n",constantName,constantName];
		}
		return constantNames.count;
	});
	
	addTask(@"init functions",TYPE_ONCE,^int()
	{
		functionNames=NSMutableArray.alloc.init;
		return RET_NULL;
	});
	
	addTask(@"add functions",TYPE_PER_SYMBOL,^int(NSString* symbol)
	{
		[functionNames addObject:symbol];
		return RET_DONE_DELETE;
	});
	
	addTask(@"remove shim functions",TYPE_ONCE,^int()
	{
		unsigned int count=0;
		for(unsigned int index=0;index<functionNames.count;index++)
		{
			NSString* check=[NSString stringWithFormat:@" %@(",functionNames[index]];
			if([shims containsString:check])
			{
				[functionNames removeObjectAtIndex:index];
				index--;
				count++;
			}
		}
		return count;
	});
	
	addTask(@"commit functions",TYPE_ONCE,^int()
	{
		for(NSString* functionName in functionNames)
		{
			[output appendFormat:@"unsigned long %@()\n{\n\treturn 0;\n}\n",functionName];
		}
		return functionNames.count;
	});
	
	addTask(@"import main",TYPE_ONCE,^int()
	{
		if(shimMainPath)
		{
			[output appendFormat:@"#import \"%@\"\n",shimMainPath];
			return RET_YES;
		}
		return RET_NO;
	});
	
	addTask(@"write output",TYPE_ONCE,^int()
	{
		NSError* error=nil;
		[output writeToFile:outPath atomically:false encoding:NSUTF8StringEncoding error:&error];
		return error?RET_ERROR:RET_NULL;
	});
}

void runTasks()
{
	for(unsigned int index=0;index<taskNames.count;index++)
	{
		trace(@"  %@",taskNames[index]);
		
		switch(taskTypes[index].intValue)
		{
			case TYPE_ONCE:
			{
				int ret=taskBlocks[index]();
				switch(ret)
				{
					case RET_ERROR:
					trace(@"    failed");
					exit(1);
					
					case RET_NULL:
					trace(@"    done");
					break;
					
					case RET_YES:
					trace(@"    yes");
					break;
					
					case RET_NO:
					trace(@"    no");
					break;
					
					default:
					trace(@"    count: %d",ret);
				}
			}
			break;
			
			case TYPE_PER_SYMBOL:
			{
				unsigned int count=0;
				
				for(unsigned int symbolIndex=0;symbolIndex<symbols.count;symbolIndex++)
				{
					int ret=taskBlocks[index](symbols[symbolIndex]);
					switch(ret)
					{
						case RET_ERROR:
						trace(@"    failed");
						exit(1);
						
						case RET_DONE_DELETE:
						[symbols removeObjectAtIndex:symbolIndex];
						symbolIndex--;
						
						case RET_DONE_KEEP:
						
						count++;
					}
				}
				
				trace(@"    count: %d",count);
			}
			break;
		}
	}
}

int main(int argCount,char** argList)
{
	if(argCount!=5)
	{
		trace(@"usage: %s old.dylib new.dylib shims_dir out.m",argList[0]);
		return 1;
	}
	
	oldPath=[NSString stringWithUTF8String:argList[1]];
	newPath=[NSString stringWithUTF8String:argList[2]];
	codePath=[NSString stringWithUTF8String:argList[3]];
	outPath=[NSString stringWithUTF8String:argList[4]];
	
	setupTasks();
	
	name=newPath.lastPathComponent;
	trace(@"name: %@",name);
	
	runTasks();
	
	return 0;
}